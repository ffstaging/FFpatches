/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#extension GL_KHR_shader_subgroup_clustered : require
#extension GL_KHR_shader_subgroup_shuffle : require

#define CFACTOR_Y444 3

layout(push_constant, scalar) uniform EstimateSliceInfo {
    uint slices_per_picture;
    uint min_quant;
    uint max_quant;
    uint bits_per_mb;
};

int av_zero_extend(int a, uint p)
{
    return int(uint(a) & ((1U << p) - 1));
}

#define GET_SIGN(x)  ((x) >> 31)
#define MAKE_CODE(x) (((x) * 2) ^ GET_SIGN(x))

int estimate_vlc(uint codebook, int val)
{
    /* number of prefix bits to switch between Rice and expGolomb */
    uint switch_bits = (codebook & 3) + 1;
    uint rice_order  =  codebook >> 5;       /* rice code order */
    uint exp_order   = (codebook >> 2) & 7;  /* exp golomb code order */

    uint switch_val  = switch_bits << rice_order;

    if (val >= switch_val)
    {
        val -= int(switch_val - (1 << exp_order));
        int exponent = findMSB(val);
        return int(exponent * 2 - exp_order + switch_bits + 1);
    }
    else
    {
        return int((val >> rice_order) + rice_order + 1);
    }
}

#define FIRST_DC_CB 0xB8 // rice_order = 5, exp_golomb_order = 6, switch_bits = 0

int estimate_dcs(inout int error, uint slice, uint plane, uint q)
{
    uint blocks_per_mb = plane != 0 && CHROMA_FACTOR != CFACTOR_Y444 ? 2 : 4;
    uint blocks_per_slice = slices[slice].mbs_per_slice * blocks_per_mb;
    int codebook = 5;
    int coeff = slices[slice].coeffs[plane][0];
    int scale = plane != 0 ? qmat_chroma[q][0] : qmat[q][0];
    int prev_dc = (coeff - 0x4000) / scale;
    int bits = estimate_vlc(FIRST_DC_CB, MAKE_CODE(prev_dc));
    int sign = 0;
    coeff = slices[slice].coeffs[plane][64];
    error += abs(coeff - 0x4000) % scale;

    for (int i = 1; i < blocks_per_slice; ++i) {
        coeff = slices[slice].coeffs[plane][i * 64];
        int dc = (coeff - 0x4000) / scale;
        error += abs(coeff - 0x4000) % scale;
        int delta = dc - prev_dc;
        int new_sign = GET_SIGN(delta);
        delta = (delta ^ sign) - sign;
        int code = MAKE_CODE(delta);
        bits += estimate_vlc(dc_codebook[codebook], code);
        codebook = min(code, 6);
        sign = new_sign;
        prev_dc = dc;
    }

    return bits;
}

#define FFALIGN(x, a) (((x)+(a)-1)&~((a)-1))
#define SCORE_LIMIT   1073741823

int estimate_acs(inout int error, uint slice, uint plane, uint q)
{
    uint blocks_per_mb = plane != 0 && CHROMA_FACTOR != CFACTOR_Y444 ? 2 : 4;
    uint blocks_per_slice = slices[slice].mbs_per_slice * blocks_per_mb;
    uint max_coeffs = blocks_per_slice << 6;
    int prev_run = 4;
    int prev_level = 2;
    int bits = 0;
    int run = 0;

    for (int i = 1; i < 64; i++) {
        for (int idx = scan[i]; idx < max_coeffs; idx += 64) {
            int coeff = slices[slice].coeffs[plane][idx];
            int quant = plane != 0 ? qmat_chroma[q][scan[i]] : qmat[q][scan[i]];
            int level = coeff / quant;
            error += abs(coeff) % quant;
            if (level != 0) {
                int abs_level = abs(level);
                bits += estimate_vlc(run_to_cb[prev_run], run);
                bits += estimate_vlc(level_to_cb[prev_level], abs_level - 1) + 1;
                prev_run = min(run, 15);
                prev_level = min(abs_level, 9);
                run = 0;
            } else {
                run++;
            }
        }
    }

    return bits;
}

int estimate_slice_plane(inout int error, uint slice, uint plane, uint q)
{
    int bits = 0;
    bits += estimate_dcs(error, slice, plane, q);
    bits += estimate_acs(error, slice, plane, q);
    return FFALIGN(bits, 8);
}

int est_alpha_diff(int cur, int prev)
{
    const int dbits = (ALPHA_BITS == 8) ? 4 : 7;
    const int dsize = 1 << dbits - 1;
    int diff = cur - prev;

    diff = av_zero_extend(diff, ALPHA_BITS);
    if (diff >= (1 << ALPHA_BITS) - dsize)
        diff -= 1 << ALPHA_BITS;
    if (diff < -dsize || diff > dsize || diff == 0)
        return ALPHA_BITS + 1;
    else
        return dbits + 1;
}

int estimate_alpha_plane(uint slice)
{
    const int mask  = (1 << ALPHA_BITS) - 1;
    const int num_coeffs = int(slices[slice].mbs_per_slice) * 256;
    int prev = mask, cur;
    int idx = 0;
    int run = 0;
    int bits;

    cur = slices[slice].coeffs[3][idx++];
    bits = est_alpha_diff(cur, prev);
    prev = cur;
    do {
        cur = slices[slice].coeffs[3][idx++];
        if (cur != prev) {
            if (run == 0)
                bits++;
            else if (run < 0x10)
                bits += 4;
            else
                bits += 15;
            bits += est_alpha_diff(cur, prev);
            prev = cur;
            run  = 0;
        } else {
            run++;
        }
    } while (idx < num_coeffs);

    if (run != 0) {
        if (run < 0x10)
            bits += 4;
        else
            bits += 15;
    }

    return bits;
}

int sum_of_planes(int value)
{
#if NUM_PLANES == 3
    uint base = (gl_SubgroupInvocationID / 3) * 3;
    return subgroupShuffle(value, base) + subgroupShuffle(value, base + 1) + subgroupShuffle(value, base + 2);
#else
    return subgroupClusteredAdd(value, 4);
#endif
}

void main()
{
    uint slice = gl_GlobalInvocationID.x / NUM_PLANES;
    uint plane = gl_LocalInvocationID.x % NUM_PLANES;
    uint q = min_quant + gl_GlobalInvocationID.y;
    if (slice >= slices_per_picture)
        return;

    /* Estimate slice bits and error for specified quantizer and plane */
    int error = 0;
    int bits = 0;
    if (plane == 3)
        bits = estimate_alpha_plane(slice);
    else
        bits = estimate_slice_plane(error, slice, plane, q);

    /* Write results to score buffer */
    scores[slice].bits[q][plane] = bits;
    scores[slice].score[q][plane] = error;

    /* Accumulate total bits and error of all planes */
    int total_bits = sum_of_planes(bits);
    int total_score = sum_of_planes(error);
    if (total_bits > 65000 * 8)
        total_score = SCORE_LIMIT;
    scores[slice].total_bits[q] = total_bits;
    scores[slice].total_score[q] = total_score;

    if (q != max_quant)
        return;

    /* Task threads that computed max_quant to also compute overquant if necessary */
    uint mbs_per_slice = slices[slice].mbs_per_slice;
    if (total_bits <= bits_per_mb * mbs_per_slice)
    {
        /* Overquant isn't needed for this slice */
        scores[slice].total_bits[max_quant + 1] = total_bits;
        scores[slice].total_score[max_quant + 1] = total_score + 1;
        scores[slice].overquant = max_quant;
    }
    else
    {
        /* Keep searching until an encoding fits our budget */
        for (q = max_quant + 1; q < 128; ++q)
        {
            /* Estimate slice bits and error for specified quantizer and plane */
            error = 0;
            bits = 0;
            if (plane == 3)
                bits = estimate_alpha_plane(slice);
            else
                bits = estimate_slice_plane(error, slice, plane, q);

            /* Accumulate total bits and error of all planes */
            total_bits = sum_of_planes(bits);
            total_score = sum_of_planes(error);

            /* If estimated bits fit within budget, we are done */
            if (total_bits <= bits_per_mb * mbs_per_slice)
                break;
        }

        scores[slice].bits[max_quant + 1][plane] = bits;
        scores[slice].score[max_quant + 1][plane] = error;
        scores[slice].total_bits[max_quant + 1] = total_bits;
        scores[slice].total_score[max_quant + 1] = total_score;
        scores[slice].overquant = q;
    }
}