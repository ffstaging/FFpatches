/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#extension GL_EXT_samplerless_texture_functions : require

/* Table of possible edge slice configurations */
const uvec3 edge_mps_table[8] = uvec3[](
    uvec3(0, 0, 0),
    uvec3(1, 0, 0),
    uvec3(2, 0, 0),
    uvec3(2, 1, 0),
    uvec3(4, 0, 0),
    uvec3(4, 1, 0),
    uvec3(4, 2, 0),
    uvec3(4, 2, 1)
);

void main()
{
    ivec2 coord = min(ivec2(gl_GlobalInvocationID.xy), textureSize(plane, 0) - ivec2(1));
    int alpha = texelFetch(plane, coord, 0).x;

#if ALPHA_BITS == 8
    alpha >>= 2;
#else
    alpha = (alpha << 6) | (alpha >> 4);
#endif

    uint mbs_per_slice = MAX_MBS_PER_SLICE;
    uint slices_width = WIDTH_IN_MB / mbs_per_slice;
    uint mb_width = slices_width * mbs_per_slice;
    uint slice_x = gl_WorkGroupID.x / mbs_per_slice;
    uint slice_y = gl_WorkGroupID.y;
    uvec2 slice_base = uvec2(slice_x, slice_y) * (mbs_per_slice * 16u);

    /* Handle slice macroblock size reduction on edge slices */
    if (gl_WorkGroupID.x >= mb_width)
    {
        uint edge_mb = gl_WorkGroupID.x - mb_width;
        uvec3 table = edge_mps_table[WIDTH_IN_MB - mb_width];
        uvec3 base = uvec3(0, table.x, table.x + table.y);
        uint edge_slice = edge_mb < base.y ? 0 : (edge_mb < base.z ? 1 : 2);
        slice_x += edge_slice;
        slice_base += base[edge_slice] * (DCTSIZE * 2u);
        mbs_per_slice = table[edge_slice];
    }

    uint slice = slice_y * SLICES_PITCH + slice_x;
    uvec2 coeff_coord = uvec2(coord) - slice_base;
    uint coeff = coeff_coord.y * (mbs_per_slice * 16u) + coeff_coord.x;
    slices[slice].coeffs[3][coeff] = int16_t(alpha);
}