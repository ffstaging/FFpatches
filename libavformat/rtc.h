/*
 * RTC definitions
 * Copyright (c) 2002 Fabrice Bellard
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef AVFORMAT_RTC_H
#define AVFORMAT_RTC_H

#include <stdint.h>
#include "avformat.h"
#include "url.h"
#include "tls.h"
#include "srtp.h"
#include "rtpdec.h"
#include "network.h"

#include "libavutil/base64.h"
#include "libavutil/lfg.h"
#include "libavutil/log.h"
#include "libavutil/opt.h"

enum RTCState {
    RTC_STATE_NONE,

    /* The initial state. */
    RTC_STATE_INIT,
    /* The muxer has sent the offer to the peer. */
    RTC_STATE_OFFER,
    /* The muxer has received the answer from the peer. */
    RTC_STATE_ANSWER,
    /**
     * After parsing the answer received from the peer, the muxer negotiates the abilities
     * in the offer that it generated.
     */
    RTC_STATE_NEGOTIATED,
    /* The muxer has connected to the peer via UDP. */
    RTC_STATE_UDP_CONNECTED,
    /* The muxer has sent the ICE request to the peer. */
    RTC_STATE_ICE_CONNECTING,
    /* The muxer has received the ICE response from the peer. */
    RTC_STATE_ICE_CONNECTED,
    /* The muxer has finished the DTLS handshake with the peer. */
    RTC_STATE_DTLS_FINISHED,
    /* The muxer has finished the SRTP setup. */
    RTC_STATE_SRTP_FINISHED,
    /* The muxer is ready to send/receive media frames. */
    RTC_STATE_READY,
    /* The muxer is failed. */
    RTC_STATE_FAILED,
};

/**
 * The size of the Secure Real-time Transport Protocol (SRTP) master key material
 * that is exported by Secure Sockets Layer (SSL) after a successful Datagram
 * Transport Layer Security (DTLS) handshake. This material consists of a key
 * of 16 bytes and a salt of 14 bytes.
 */
#define DTLS_SRTP_KEY_LEN 16
#define DTLS_SRTP_SALT_LEN 14
#define RTC_US_PER_MS 1000

/**
 * Maximum size of the buffer for sending and receiving UDP packets.
 * Please note that this size does not limit the size of the UDP packet that can be sent.
 * To set the limit for packet size, modify the `pkt_size` parameter.
 * For instance, it is possible to set the UDP buffer to 4096 to send or receive packets,
 * but please keep in mind that the `pkt_size` option limits the packet size to 1400.
 */
#define MAX_UDP_BUFFER_SIZE 4096

/**
 * RTC stream information parsed from SDP
 */
typedef struct RTCStreamInfo {
    int payload_type;
    enum AVMediaType codec_type;
    char *codec_name;
    uint32_t ssrc;
    int clock_rate;
    char *fmtp;
    int channels;

    char *direction;

    /* RTX information */
    int rtx_pt;
    uint32_t rtx_ssrc;
} RTCStreamInfo;

typedef struct RTCContext {
    AVClass *av_class;

    /* The state of the RTC connection. */
    enum RTCState state;

    /* Parameters for the input audio and video codecs. */
    AVCodecParameters *audio_par;
    AVCodecParameters *video_par;

    /**
     * The h264_mp4toannexb Bitstream Filter (BSF) bypasses the AnnexB packet;
     * therefore, it is essential to insert the SPS and PPS before each IDR frame
     * in such cases.
     */
    int h264_annexb_insert_sps_pps;

    /* The random number generator. */
    AVLFG rnd;

    /* The ICE username and pwd fragment generated by the muxer. */
    char ice_ufrag_local[9];
    char ice_pwd_local[33];
    /* The SSRC of the audio and video stream, generated by the muxer. */
    uint32_t audio_ssrc;
    uint32_t video_ssrc;
    uint32_t video_rtx_ssrc;

    uint16_t audio_first_seq;
    uint16_t video_first_seq;
    /* The PT(Payload Type) of stream, generated by the muxer. */
    uint8_t audio_payload_type;
    uint8_t video_payload_type;
    uint8_t video_rtx_payload_type;
    /**
     * This is the SDP offer generated by the muxer based on the codec parameters,
     * DTLS, and ICE information.
     */
    char *sdp_offer;

    int is_peer_ice_lite;
    uint64_t ice_tie_breaker; // random 64 bit, for ICE-CONTROLLING
    /* The ICE username and pwd from remote server. */
    char *ice_ufrag_remote;
    char *ice_pwd_remote;
    /**
     * This represents the ICE candidate protocol, priority, host and port.
     * Currently, we only support one candidate and choose the first UDP candidate.
     * However, we plan to support multiple candidates in the future.
     */
    char *ice_protocol;
    char *ice_host;
    int ice_port;

    /* The SDP answer received from the WebRTC server. */
    char *sdp_answer;
    /* The resource URL returned in the Location header of WHIP/WHEP HTTP response. */
    char *rtc_resource_url;

    /* These variables represent timestamps used for calculating and tracking the cost. */
    int64_t rtc_starttime;
    int64_t rtc_init_time;
    int64_t rtc_offer_time;
    int64_t rtc_answer_time;
    int64_t rtc_udp_time;
    int64_t rtc_ice_time;
    int64_t rtc_dtls_time;
    int64_t rtc_srtp_time;
    int64_t rtc_last_consent_tx_time;
    int64_t rtc_last_consent_rx_time;

    /* The certificate and private key content used for DTLS handshake */
    char cert_buf[MAX_CERTIFICATE_SIZE];
    char key_buf[MAX_CERTIFICATE_SIZE];
    /* The fingerprint of certificate, used in SDP offer. */
    char *dtls_fingerprint;
    /**
     * This represents the material used to build the SRTP master key. It is
     * generated by DTLS and has the following layout:
     *          16B         16B         14B             14B
     *      client_key | server_key | client_salt | server_salt
     */
    uint8_t dtls_srtp_materials[(DTLS_SRTP_KEY_LEN + DTLS_SRTP_SALT_LEN) * 2];

    char ssl_error_message[256];

    /* TODO: Use AVIOContext instead of URLContext */
    URLContext *dtls_uc;

    /* The SRTP send context, to encrypt outgoing packets. */
    SRTPContext srtp_audio_send;
    SRTPContext srtp_video_send;
    SRTPContext srtp_video_rtx_send;
    SRTPContext srtp_rtcp_send;
    /* The SRTP receive context, to decrypt incoming packets. */
    SRTPContext srtp_recv;

    /* SRTP suite and parameters */
    char suite[64];
    char send_suite_param[AV_BASE64_SIZE(DTLS_SRTP_KEY_LEN + DTLS_SRTP_SALT_LEN)];
    char recv_suite_param[AV_BASE64_SIZE(DTLS_SRTP_KEY_LEN + DTLS_SRTP_SALT_LEN)];

    /* The UDP transport is used for delivering ICE, DTLS and SRTP packets. */
    URLContext *udp;
    /* The buffer for UDP transmission. */
    uint8_t* buf;
    int bufsize;

    /* The timeout in milliseconds for ICE and DTLS handshake. */
    int handshake_timeout;
    /**
     * The size of RTP packet, should generally be set to MTU.
     * Note that pion requires a smaller value, for example, 1200.
     */
    int pkt_size;
    int buffer_size;/* Underlying protocol send/receive buffer size */
    /**
     * The optional Bearer token for WHIP/WHEP Authorization.
     * See https://www.ietf.org/archive/id/draft-ietf-wish-whip-08.html#name-authentication-and-authoriz
     */
    char* authorization;
    /* The certificate and private key used for DTLS handshake. */
    char* cert_file;
    char* key_file;

    /* for demuxer */
    RTCStreamInfo **stream_infos;
    int nb_stream_infos;
} RTCContext;

int ff_rtc_initialize(AVFormatContext *s);

int ff_rtc_connect(AVFormatContext *s);

void ff_rtc_close(AVFormatContext *s);

int ff_rtc_is_dtls_packet(uint8_t *b, int size);

int ff_rtc_ice_is_binding_request(uint8_t *b, int size);

int ff_rtc_ice_is_binding_response(uint8_t *b, int size);

int ff_rtc_ice_create_request(AVFormatContext *s, uint8_t *buf, int buf_size, int *request_size);

int ff_rtc_media_is_rtp_rtcp(const uint8_t *b, int size);

int ff_rtc_media_is_rtcp(const uint8_t *b, int size);

extern const AVOption ff_rtc_options[];

#endif /* AVFORMAT_RTC_H */
